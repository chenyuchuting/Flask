1. Local对象
    1.1 在Flask中，类似于request的对象，其实是绑定到了一个werkzeug.local.Local对象上。这样，即使是同一个对象，那么在多个线程中都是隔离的。
    1.2 只要满足绑定到这个对象上的属性，在每个线程中都是隔离的，那么他就叫做Thread Local对象。
2. Flask上下文
    2.1 Flask的上下文与文章的上下文意思基本相同，上下文分为程序上下文和请求上下文，程序上下文储存了程序所运行的信息，请求上下文包含了请求的各种信息。
    2.2 Flask会在每个请求产生后自动激活当前请求的上下文，激活请求上下文后request被临时设为全局可访问，而当每个请求结束后，Flask就销毁对应的请求上下文。请求对象只在各自的线程内是全局的。
    2.3 Flask中的上下文变量
        2.3.1 current_app：指向处理请求的当前程序实例
        2.3.2 g：用于储存全局的数据，每次请求都会重设。
        2.3.3 request：封装客户端发出的请求报文数据。
        2.3.4 session：用于记住请求之间的数据，通过签名的cookie实现。
    2.4 激活上下文，当我们使用flask run命令启动程序时等其它3种命令时就会激活上下文，或是显式地使用push()方法推送（激活）上下文，在执行完相关操作时使用pop()方法销毁上下文。
    2.5 同样依赖于上下文的还有url_for()、 jsonify()等函数， 所以你也只能在视图函数中使用它们。 其中jsonify()函数内部调用中使用了current_app变量。
3. 为什么上下文需要放在栈中
    3.1 应用上下文：Flask底层是基于werkzeug，werkzeg是可以包含多个app的，所以这时候用一个栈来保存。如果你在使用app1，那么app1应该是要在栈的顶部，如果用完了app1，那么app1应该从栈中删除。方便其他代码使用下面的app。
    3.2 如果在写测试代码，或者离线脚本的时候，我们有时候可能需要创建多个请求上下文，这时候就需要存放到一个栈中了。使用哪个请求上下文的时候，就把对应的请求上下文放到栈的顶部，用完了就要把这个请求上下文从栈中移除掉。
